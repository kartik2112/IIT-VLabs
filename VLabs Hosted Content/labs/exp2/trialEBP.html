<!DOCTYPE html>
<html>
	<head>
 		<meta charset = "UTF-8">
 		<title>EBP Trial</title>
 		<link rel = "stylesheet" type = "text/css" href = "http://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css" />
 		<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jsxgraph/0.99.5/jsxgraphcore.js"></script>
 	</head>
	<body>
		<form>
			Enter w11:<input type="number" name="w11" id="w11" value="1"/>
			<br />
			Enter w12:<input type="number" name="w12" id="w12" value="-1"/><br />
			Enter b1:<input type="number" name="b1" id="b1" value="-1"/><br />
			Enter w21:<input type="number" name="w21" id="w21" value="2"/><br />
			Enter w22:<input type="number" name="w22" id="w22" value="3"/><br />
			Enter b2:<input type="number" name="b2" id="b2" value="-1"/><br />
			Enter v1:<input type="number" name="v1" id="v1" value="-1"/><br />
			Enter v2:<input type="number" name="v2" id="v2" value="-2"/><br />
			Enter b3:<input type="number" name="b3" id="b3" value="-1"/><br />
			Enter Learning Rate:<input type="number" name="LR" id="LR" value="0.75"/><br />
			Enter number of epochs for which the network must train:<input type="number" name="iter" id="iter" value="1"/><br />
			<input type="button" onclick="initiateTraining()" name="initate" value="Start Training">
		</form>
		<div id="output">
			<div id="box" class="jxgbox" style="width:400px; height:400px;"></div>
			<div id="box1" class="jxgbox" style="width:400px; height:400px;"></div>
		</div>
		<div id="outputText"></div>
		<script type="text/javascript">
			var x1=[0,0,1,1];
			var x2=[0,1,0,1];
			var z=[0,1,1,0];
			var e=Math.E;
			var z1=[]
			var z2=[]
			var y1=[]
			var y2=[]
			var yin=[]
			var y=[];
			var i;
			function initiateTraining()
			{
				var board = JXG.JSXGraph.initBoard('box',{axis:true, boundingbox:[-2, 2, 2, -2]});  //Creates the cartesian graph
				var board1 = JXG.JSXGraph.initBoard('box1',{axis:true, boundingbox:[-2, 2, 2, -2]});  //Creates the cartesian graph

				var constPointSize=5;
				var OP1 = board.create('point',[0,0], {size:constPointSize,face:'x',fixed:true});
				var OP2 = board.create('point',[0,1], {size:constPointSize,face:'^',fixed:true});
				var OP3 = board.create('point',[1,0], {size:constPointSize,face:'^',fixed:true});
				var OP4 = board.create('point',[1,1], {size:constPointSize,face:'x',fixed:true});

				var theDiv = document.getElementById("outputText");
				theDiv.innerHTML="";
				var x = document.createElement("br");
				
				var w11=parseFloat(document.getElementById('w11').value);
				var w12=parseFloat(document.getElementById('w12').value);
				var b1=parseFloat(document.getElementById('b1').value);

				var w21=parseFloat(document.getElementById('w21').value);
				var w22=parseFloat(document.getElementById('w22').value);
				var b2=parseFloat(document.getElementById('b2').value);

				var v1=parseFloat(document.getElementById('v1').value);
				var v2=parseFloat(document.getElementById('v2').value);
				var b3=parseFloat(document.getElementById('b3').value);

				var learningRate=parseFloat(document.getElementById('LR').value);
				var iterations=parseFloat(document.getElementById('iter').value);

				decisionBoundary1 = board.create('line', [-b1, Number(w11), Number(w21)]);
				decisionBoundary2 = board.create('line', [-b2, Number(w12), Number(w22)]);
				i=1;
				var tim=setInterval(function(){
					//JXG.JSXGraph.freeBoard(board);
				    //JXG.JSXGraph.freeBoard(board1);

				    var board = JXG.JSXGraph.initBoard('box',{axis:true, boundingbox:[-0.5, 2, 2, -0.5]});  //Creates the cartesian graph
					var board1 = JXG.JSXGraph.initBoard('box1',{axis:true, boundingbox:[-0.5, 2, 2, -0.5]});  //Creates the cartesian graph

					var constPointSize=5;
					var OP1 = board.create('point',[0,0], {size:constPointSize,face:'x',fixed:true});
					var OP2 = board.create('point',[0,1], {size:constPointSize,face:'^',fixed:true});
					var OP3 = board.create('point',[1,0], {size:constPointSize,face:'^',fixed:true});
					var OP4 = board.create('point',[1,1], {size:constPointSize,face:'x',fixed:true});

					for(j=0;j<x1.length;j++)
					{
						z1[j]=x1[j]*w11+x2[j]*w21+b1;  // Computation at hidden neuron 1
        				z2[j]=x1[j]*w21+x2[j]*w22+b2;  // Computation at hidden neuron 2

        				//Output at hidden layer nuerons
        				var temp=Math.pow(e,-z1[j]);
        				y1[j]=1/(1+temp);
        				var temp=Math.pow(e,-z2[j]);
        				y2[j]=1/(1+temp);

        				//Calculation at output nueron
        				yin[j]=y1[j]*v1+y2[j]*v2+b3;

        				//Output at output nueron
        				var temp=Math.pow(e,-yin[j]);
        				y[j]=1/(1+temp);

        				//Calculation of delta values for each neuron
        				var delta1=y[j]*(1-y[j])*(z[j]-y[j]);
        				var delta2 = y1[j]*(1-y1[j])*v1*delta1;
        				var delta3 = y2[j]*(1-y2[j])*v2*delta1;

        				//Update Bias:
        				b1=b1+learningRate*delta2;
        				b2=b2+learningRate*delta3;
        				b3=b3+learningRate*delta1;

        				//Changing weights between input neurons and hidden neurons
                        w11=w11+learningRate*x1[j]*delta2;
				        w12=w12+learningRate*x1[j]*delta2;
				        w21=w21+learningRate*x2[j]*delta3;
				        w22=w22+learningRate*x2[j]*delta3;

				        // Changing weights between output neurons and hidden neurons
                        v1=v1+learningRate*y1[j]*delta1;
				        v2=v2+learningRate*y2[j]*delta1;
					}
					decisionBoundary1 = board.create('line', [b1, Number(w11), Number(w21)]);
					decisionBoundary2 = board.create('line', [b2, Number(w12), Number(w22)]);
					var tempZ1=[];
					var tempZ2=[];
					for(j=0;j<z1.length;j++)
					{
						if(z1[j]>=0)
							tempZ1[j]=1;
						else
							tempZ1[j]=0;
						if(z2[j]>=0)
							tempZ2[j]=1;
						else
							tempZ2[j]=0;
					}
					//[Number(tempZ1[j]),Number(tempZ2[j])]
					for(j=0;j<tempZ1.length;j++)
					{
						if(z[j]==0)
							var finalPoints = board1.create('point',[y1[j],y2[j]], {size:constPointSize,face:'x',fixed:true,name:'Group 0'});
						else
							var finalPoints = board1.create('point',[y1[j],y2[j]], {size:constPointSize,face:'^',fixed:true,name:'Group 1'});
					}
					finalBoundary=board1.create('line',[b3, Number(v1), Number(v2)]);
					i++;
					displayFinalOP();
					if(i>=iterations)
					{
						clearInterval(tim);
						displayFinalOP();
					}	
				},1);
			}
			function displayFinalOP(){
				var squaredError=0;
				for(k=0;k<y.length;k++)
				{
					squaredError+=Math.pow(z[k]-y[k],2);
				}
				var RMSError=Math.sqrt(squaredError/y1.length);
			    var theDiv = document.getElementById("outputText");
				var content = document.createTextNode("Ouput of network after "+i+" iteration:"+y+" RMS Error:"+RMSError.toFixed(6));
				var x = document.createElement("br");
				theDiv.appendChild(content);
				theDiv.appendChild(x);	
			}
		</script>
	</body>
</html>
